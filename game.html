<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Idea Fusion — Neuron Lab</title>
<style>
  /* Keep the color scheme exactly as requested; subtle tweaks only */
  :root{
    --bg-1: #111117;
    --bg-2: #1a1a1f;
    --panel-bg: rgba(30,30,40,0.94);
    --glass-accent: rgba(100,140,220,0.18);
    --muted-text: rgba(210,225,255,0.9);
  }

  /* base */
  html,body{height:100%;margin:0;background:
    radial-gradient(1200px 600px at 30% 30%, rgba(255,255,255,0.02), transparent 18%),
    radial-gradient(800px 400px at 70% 70%, rgba(255,255,255,0.01), transparent 20%),
    linear-gradient(135deg,var(--bg-1) 0%, var(--bg-2) 100%);color:#fff;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;font-size:110%;-webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;}
  #ecosystem{position:relative; width:100vw; height:100vh; overflow:hidden; touch-action:none;}

  canvas{position:absolute; top:0; left:0; width:100%; height:100%; display:block; z-index:0;}

  /* Dashboard toggle (left) */
  #dashboardToggle{
    position:fixed; left:12px; top:12px; width:44px; height:44px; border-radius:6px;
    background:rgba(20,22,32,0.85); display:flex; align-items:center; justify-content:center;
    box-shadow:0 6px 16px rgba(0,0,0,0.6), inset 0 0 10px rgba(255,255,255,0.02);
    z-index:10020; cursor:pointer; user-select:none;
  }
  #dashboardToggle svg{width:22px; height:22px; fill:#9fbfff; opacity:0.98;}

  /* Controls panel (left) - pushed down 60px so toggle doesn't cover "Dashboard" heading */
  #controlsPanel{
    position:fixed; left:0; top:0; height:100%; width:320px; max-width:85vw;
    transform:translateX(-340px); transition:transform 420ms cubic-bezier(.2,.9,.2,1);
    background: linear-gradient(180deg, rgba(24,26,38,0.98), rgba(18,20,30,0.96));
    box-shadow: 4px 0 24px rgba(20, 30, 60, 0.7); z-index:10010; border-radius:0 6px 6px 0;
    padding: 60px 18px 18px 18px; /* <-- pushed down 60px so header sits below toggle */
    box-sizing:border-box; color:var(--muted-text);
  }
  #controlsPanel.visible{ transform: translateX(0); }

  #controlsPanel h2{ margin:0 0 6px 0; font-size:1.25rem; color:#dfeaff; }
  #controlsPanel .controlRow{ margin-top:12px; }
  #controlsPanel label{ display:block; font-weight:600; margin-bottom:6px; color: #cfe0ff; }
  #controlsPanel input[type=range]{ width:100%; }
  #resetBtn{ margin-top:20px; width:100%; padding:10px; border-radius:6px; border:0; background:#375a9c; color:white; font-weight:700; box-shadow:0 6px 14px rgba(40,60,120,0.45); cursor:pointer; }

  /* Popup (idea panel) */
  .popup{
    position:fixed; z-index:100; max-width:300px; background: var(--panel-bg);
    border-radius:6px; padding:12px 14px; box-sizing:border-box; color:white;
    box-shadow: 0 12px 30px rgba(10,12,18,0.7), inset 0 0 10px rgba(255,255,255,0.02);
    backdrop-filter: blur(10px) saturate(140%);
    transition:opacity 300ms ease, transform 220ms ease;
    touch-action:none;
    user-select:text;
  }
  .popup.lowOpacity{ opacity:0.12; pointer-events:none; }
  .popup.fading{ animation:fadeWobble 5s forwards; }
  @keyframes fadeWobble { 0%{opacity:1; transform:translateY(0)} 40%{opacity:0.6; transform:translateY(-6px) rotate(.8deg)} 100%{opacity:0; transform:translateY(10px)} }

  .popup .closeBtn{ position:absolute; right:8px; top:6px; cursor:pointer; color:#e6eefc; font-weight:800; font-size:18px; user-select:none; }
  .popup .pinBtn{ position:absolute; left:8px; top:8px; width:18px; height:18px; cursor:pointer; opacity:.9; }
  .popup .pinBtn.pinned{ filter: drop-shadow(0 0 6px rgba(110,160,255,0.45)); opacity:1; }
  .popup .ideaText{ color:#fff; margin:0; padding-right:36px; white-space:normal; word-break:break-word; line-height:1.25; }
  .popup .linkedIdeas{ margin-top:10px; color:#b9d6ff; font-weight:700; font-size:0.95rem; }
  .popup .linkedIdeas span{ cursor:pointer; margin-right:8px; text-decoration:underline; color:#dbeaff; }

  /* make textarea for custom node */
  .popup textarea{ width:100%; min-height:80px; resize:vertical; margin-top:8px; padding:8px; border-radius:6px; border:0; background:rgba(255,255,255,0.05); color:white; font-size:1rem; box-sizing:border-box; }

  /* small pin icon */
  svg.icon{ width:18px; height:18px; display:block; }

  /* helper for accessibility focus */
  [role="button"]:focus{ outline:3px solid rgba(120,160,255,0.18); outline-offset:2px; border-radius:6px; }

  /* ensure all border radius changed to 6px in UI bits */
  input[type=range], #resetBtn, #dashboardToggle, .popup, #controlsPanel{ border-radius:6px; }

  /* keep dashboard header visible and not overlapped by toggle;
     we pushed the controlsPanel down 60px and the toggle sits in that gap */
  #controlsPanel h2 { padding-top: 2px; }

  /* small mobile tweaks */
  @media (max-width:700px){
    #controlsPanel{ width: 84vw; padding-left: 58px; } /* keep room for toggle */
    #dashboardToggle{ left:8px; top:8px; }
  }
</style>
</head>
<body>
  <div id="ecosystem"><canvas id="canvas"></canvas></div>

  <!-- dashboard toggle -->
  <div id="dashboardToggle" role="button" aria-pressed="false" title="Open dashboard">
    <svg viewBox="0 0 24 24" class="icon"><path d="M3 6h18M3 12h18M3 18h18" stroke="none" fill="currentColor"/></svg>
  </div>

  <!-- Controls panel (left) -->
  <aside id="controlsPanel" aria-hidden="true" aria-label="Dashboard">
    <h2>Dashboard</h2>

    <div class="controlRow">
      <label for="ideaCountSlider">Idea Count: <span id="ideaCountLabel">5</span></label>
      <input id="ideaCountSlider" type="range" min="3" max="18" step="1" value="5" />
    </div>

    <div class="controlRow">
      <label for="growthRateSlider">Growth Rate: <span id="growthRateLabel">0.5</span></label>
      <input id="growthRateSlider" type="range" min="0.1" max="1.2" step="0.05" value="0.5" />
    </div>

    <div class="controlRow">
      <label for="challengeSlider">Challenge Strength: <span id="challengeStrengthLabel">0.4</span></label>
      <input id="challengeSlider" type="range" min="0" max="1" step="0.05" value="0.4" />
    </div>

    <div class="controlRow">
      <label for="stabilitySlider">Stability Threshold: <span id="stabilityThresholdLabel">0.7</span></label>
      <input id="stabilitySlider" type="range" min="0.3" max="0.95" step="0.05" value="0.7" />
    </div>

    <button id="resetBtn">Reset ecosystem</button>
  </aside>

<script>
(() => {
  /* ---- Environment & canvas setup ---- */
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: true });
  let DPR = Math.max(1, window.devicePixelRatio || 1);
  let width = 0, height = 0;

  function resizeCanvas(){
    width = document.documentElement.clientWidth;
    height = document.documentElement.clientHeight;
    canvas.width = Math.floor(width * DPR);
    canvas.height = Math.floor(height * DPR);
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  /* ---- UI references ---- */
  const dashboardToggle = document.getElementById('dashboardToggle');
  const controlsPanel = document.getElementById('controlsPanel');
  const ideaCountSlider = document.getElementById('ideaCountSlider');
  const ideaCountLabel = document.getElementById('ideaCountLabel');
  const growthRateSlider = document.getElementById('growthRateSlider');
  const growthRateLabel = document.getElementById('growthRateLabel');
  const challengeSlider = document.getElementById('challengeSlider');
  const challengeStrengthLabel = document.getElementById('challengeStrengthLabel');
  const stabilitySlider = document.getElementById('stabilitySlider');
  const stabilityThresholdLabel = document.getElementById('stabilityThresholdLabel');
  const resetBtn = document.getElementById('resetBtn');

  /* ---- Configuration ---- */
  const MARGIN = 30;               // keep nodes 30px from edges
  const INITIAL_COUNT = parseInt(ideaCountSlider.value,10) || 5;

  /* ---- Idea content (preserve color scheme) ---- */
  const gammaStarterIdeas = [
    "Spark your wildest creativity.",
    "Unlock unexpected connections.",
    "Dive deep into curiosity.",
    "Challenge norms with boldness.",
    "Embrace playful experimentation."
  ];
  const gammaWeirdIdeas = [
    "What if you could see invisible radio waves?",
    "What would you do if you could pause time?",
    "Imagine communicating through dreams.",
    "Could thoughts be shared instantly worldwide?",
    "What if your shadow had its own mind?",
    "Can memories be planted like seeds?",
    "Could colors have sounds we never heard?",
    "What if emotions could power machines?",
    "What if trees whispered secrets?",
    "What if gravity reversed for a second?"
  ];

  const starterPool = [...gammaStarterIdeas, ...gammaWeirdIdeas];

  /* ---- Data structures ---- */
  let ideaNodes = [];       // array of nodes
  let nextId = 0;
  let openPopups = [];      // active popup DOMs
  let currentChainIds = []; // selection chain order
  let highlightedPath = new Set();

  /* ---- Visual helper functions ---- */
  function rand(min,max){ return min + Math.random()*(max-min); }
  function choose(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  // Return hsl string with same scheme (blue-ish baseline), can pass overrides
  function blueHue(base=215, variance=24, sat=70, light=60, a=1){
    let h = (base + (Math.random()*variance - variance/2)) % 360;
    return `hsl(${h}, ${sat}%, ${light}%)`;
  }

  // Reddish orange for the custom node
  function customColor(){
    return `hsl(${15 + Math.random()*10}, 85%, 55%)`; // warm orange-reddish
  }

  // Adjust HSL-like string brightness (naive)
  function adjustLight(hsl, deltaL){
    const m = hsl.match(/hsl\(([^,]+),\s*([^%]+)%,\s*([^%]+)%/);
    if(!m) return hsl;
    const h = +m[1], s = +m[2], l = Math.min(95, Math.max(5, +m[3] + deltaL));
    return `hsl(${h}, ${s}%, ${l}%)`;
  }

  /* ---- Node class ---- */
  class IdeaNode {
    constructor(id, ideaText, x, y, color, isCustom=false){
      this.id = id;
      this.ideaText = ideaText;
      this.x = x;
      this.y = y;
      this.color = color;
      this.isCustom = !!isCustom;
      this.connections = new Set();
      this.baseSize = 16 + Math.random()*6; // 16-22
      this.size = this.baseSize;
      this.pulse = Math.random()*Math.PI*2;
      this.jigglePhase = Math.random()*Math.PI*2;
      this.jiggleAmplitude = 0;
      this.vx = (Math.random()-0.5)*0.16;
      this.vy = (Math.random()-0.5)*0.16;
    }
    update(){
      // slow float
      this.x += this.vx;
      this.y += this.vy;
      // constraints
      this.x = Math.min(Math.max(this.x, MARGIN), width - MARGIN);
      this.y = Math.min(Math.max(this.y, MARGIN), height - MARGIN);
      // slight damping to keep slow
      this.vx *= 0.999;
      this.vy *= 0.999;

      // jiggle when connected
      this.jigglePhase += 0.06;
      this.pulse += 0.045;
      this.size = this.baseSize + Math.sin(this.pulse)*1.8;
      // set jiggle amplitude from connections (slightly scaled)
      this.jiggleAmplitude = this.connections.size > 0 ? 1.2 : 0;
    }
    draw(ctx, highlighted=false){
      const gx = this.jiggleAmplitude * Math.sin(this.jigglePhase + this.id);
      const gy = this.jiggleAmplitude * Math.cos(this.jigglePhase + this.id);
      const cx = this.x + gx;
      const cy = this.y + gy;

      // outer glow ring
      ctx.beginPath();
      ctx.fillStyle = adjustLight(this.color, highlighted ? 8 : -2);
      ctx.shadowColor = this.color;
      ctx.shadowBlur = highlighted ? 18 : 6;
      ctx.arc(cx, cy, this.size, 0, Math.PI*2);
      ctx.fill();

      // inner highlight
      ctx.shadowBlur = 0;
      ctx.beginPath();
      ctx.fillStyle = 'rgba(238, 244, 255, 0.95)';
      ctx.arc(cx, cy, this.size*0.6, 0, Math.PI*2);
      ctx.fill();
    }
  }

  /* ---- Create initial nodes + custom node ---- */
  function makeNodes(count){
    ideaNodes = [];
    nextId = 0;
    // create count-1 regular nodes
    for(let i=0;i<count-1;i++){
      const x = MARGIN + Math.random()*(width - MARGIN*2);
      const y = MARGIN + Math.random()*(height - MARGIN*2);
      const text = starterPool[(i)%starterPool.length];
      const col = blueHue(210, 40, 70, 60);
      ideaNodes.push(new IdeaNode(nextId++, text, x, y, col, false));
    }
    // add one custom reddish-orange node
    const cx = width*0.14 + Math.random()*40;
    const cy = height*0.25 + Math.random()*80;
    const custom = new IdeaNode(nextId++, "Click to add your idea (type to replace)", cx, cy, customColor(), true);
    ideaNodes.push(custom);
    // ensure there are connections
    connectNodes(ideaNodes);
  }

  function connectNodes(nodes){
    // clear existing
    nodes.forEach(n=> n.connections.clear());
    // chain them to guarantee connectivity
    for(let i=1;i<nodes.length;i++){
      nodes[i].connections.add(nodes[i-1].id);
      nodes[i-1].connections.add(nodes[i].id);
    }
    // add some extras
    const extras = Math.floor(nodes.length * 0.6);
    for(let i=0;i<extras;i++){
      const a = nodes[Math.floor(Math.random()*nodes.length)];
      const b = nodes[Math.floor(Math.random()*nodes.length)];
      if(a && b && a !== b){
        a.connections.add(b.id);
        b.connections.add(a.id);
      }
    }
  }

  /* ---- Popup management ---- */
  const ecosystemDiv = document.getElementById('ecosystem');

  function createPopupForNode(node){
    // don't duplicate
    if(openPopups.find(p => parseInt(p.dataset.nodeId) === node.id)) return;

    const popup = document.createElement('div');
    popup.className = 'popup';
    popup.dataset.nodeId = node.id.toString();
    // color-match panel with node color (slightly darker)
    popup.style.background = adjustLight(node.color, -12);
    popup.style.color = '#fff';
    popup.style.borderRadius = '6px';
    popup.style.left = `${Math.min(Math.max(node.x - 140, 8), width - 320)}px`;
    popup.style.top = `${Math.min(Math.max(node.y - 90, 8), height - 140)}px`;
    popup.style.opacity = '1';

    // ---- Insert drag handle ----
    const handle = document.createElement('div');
    handle.className = 'popupHandle';
    handle.style.height = '20px';
    handle.style.cursor = 'move';
    handle.style.marginBottom = '6px';
    handle.style.background = 'rgba(255,255,255,0.05)';
    handle.style.borderRadius = '4px';
    popup.appendChild(handle);

    // pin (svg)
    const pin = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    pin.setAttribute('viewBox','0 0 24 24');
    pin.classList.add('pinBtn');
    pin.innerHTML = '<path d="M12 2L10 8H4L9 12L6 22L12 17L18 22L15 12L20 8H14L12 2Z"></path>';
    popup.appendChild(pin);

    // close button
    const close = document.createElement('div');
    close.className = 'closeBtn';
    close.textContent = '×';
    popup.appendChild(close);

    // content - if custom node -> textarea else text
    if(node.isCustom){
      const label = document.createElement('div');
      label.style.fontWeight = 700;
      label.style.marginBottom = '6px';
      label.textContent = "Your idea starter (editable)";
      popup.appendChild(label);

      const ta = document.createElement('textarea');
      ta.removeAttribute('disabled');
      ta.autofocus = true;
      ta.addEventListener('click', e => e.stopPropagation());
      ta.placeholder = "Type a concept, a single-line prompt, or a seed idea...";
      ta.value = (node.ideaText && node.ideaText.startsWith("Click to add"))? "" : node.ideaText || "";
      popup.appendChild(ta);

      const saveBtn = document.createElement('button');
      saveBtn.textContent = "Save idea";
      saveBtn.style.marginTop = '8px';
      saveBtn.style.padding = '8px 10px';
      saveBtn.style.border = 'none';
      saveBtn.style.borderRadius = '6px';
      saveBtn.style.background = 'linear-gradient(180deg,#ff7b3d,#e85a2d)';
      saveBtn.style.color = '#fff';
      saveBtn.style.cursor = 'pointer';
      popup.appendChild(saveBtn);

      saveBtn.addEventListener('click', (e)=>{
        e.stopPropagation();
        const text = ta.value.trim();
        if(text.length>0){
          node.ideaText = text;
          node.isCustom = true;
          // update this popup text visually (we keep textarea)
          ta.value = node.ideaText;
          // if chain exists, update fusion for chain
          updateFusionForChain();
        }
        // pin the popup on save
        pin.classList.add('pinned');
        popup.dataset.pinned = '1';
      });
    } else {
      const p = document.createElement('div');
      p.className = 'ideaText';
      p.textContent = node.ideaText;
      popup.appendChild(p);
    }

    // linked ideas preview
    const linkedDiv = document.createElement('div');
    linkedDiv.className = 'linkedIdeas';
    if(node.connections.size>0){
      linkedDiv.textContent = 'Linked: ';
      node.connections.forEach(connId=>{
        const n = ideaNodes.find(it=>it.id===connId);
        if(!n) return;
        const s = document.createElement('span');
        s.textContent = (n.ideaText.length>20 ? n.ideaText.slice(0,20)+'…' : n.ideaText);
        s.title = n.ideaText;
        s.addEventListener('click', (e)=>{
          e.stopPropagation();
          selectNode(n);
        });
        linkedDiv.appendChild(s);
      });
      popup.appendChild(linkedDiv);
    }

    // append and track
    document.body.appendChild(popup);
    openPopups.push(popup);

    // dragging support (mouse + touch) with per-popup cleanup and state
    let activeDrag = false;
    let dx = 0, dy = 0;
    // Store handler refs so we can remove them later
    let onMove = null;
    let onEnd = null;
    // The startDrag/endDrag functions are per-popup
    function startDrag(ev){
      const evt = (ev.touches && ev.touches[0]) || ev;
      activeDrag = true;
      dx = evt.clientX - popup.getBoundingClientRect().left;
      dy = evt.clientY - popup.getBoundingClientRect().top;
      // auto pin when dragged
      pin.classList.add('pinned');
      popup.dataset.pinned = '1';
      popup.style.transition = 'none';
      // Prevent text selection on drag
      document.body.style.userSelect = 'none';
      // Add listeners to window (so drag works outside popup)
      window.addEventListener('mousemove', onMove);
      window.addEventListener('touchmove', onMove, {passive:false});
      window.addEventListener('mouseup', onEnd);
      window.addEventListener('touchend', onEnd);
      ev.preventDefault();
      ev.stopPropagation();
    }
    onMove = function(ev){
      if(!activeDrag) return;
      const evt = (ev.touches && ev.touches[0]) || ev;
      let nx = evt.clientX - dx;
      let ny = evt.clientY - dy;
      nx = Math.min(Math.max(nx, 6), width - popup.offsetWidth - 6);
      ny = Math.min(Math.max(ny, 6), height - popup.offsetHeight - 6);
      popup.style.left = nx + 'px';
      popup.style.top = ny + 'px';
      ev.preventDefault();
    };
    onEnd = function(ev){
      if(!activeDrag) return;
      activeDrag = false;
      popup.style.transition = '';
      // Remove listeners and cleanup
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('touchmove', onMove, {passive:false});
      window.removeEventListener('mouseup', onEnd);
      window.removeEventListener('touchend', onEnd);
      document.body.style.userSelect = '';
    };

    handle.addEventListener('mousedown', startDrag);
    handle.addEventListener('touchstart', startDrag, {passive:false});

    // Store drag cleanup logic on the popup DOM element for external cleanup
    popup._dragCleanup = function(){
      // If currently dragging, end drag and cleanup
      if(activeDrag){
        onEnd();
      } else {
        // Remove listeners if somehow still attached
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('touchmove', onMove, {passive:false});
        window.removeEventListener('mouseup', onEnd);
        window.removeEventListener('touchend', onEnd);
        document.body.style.userSelect = '';
      }
    };

    // close
    close.addEventListener('click', (e)=>{
      e.stopPropagation();
      removePopup(node.id);
    });

    // pin toggle on pin click
    pin.addEventListener('click', (e)=>{
      e.stopPropagation();
      if(pin.classList.contains('pinned')){
        pin.classList.remove('pinned');
        popup.dataset.pinned='0';
      } else {
        pin.classList.add('pinned');
        popup.dataset.pinned='1';
      }
    });

    // opacity by hover/touch - don't hide when pinned
    let fadeTO = null;
    function scheduleFade(){
      if(popup.dataset.pinned === '1') return;
      clearTimeout(fadeTO);
      fadeTO = setTimeout(()=>{ popup.classList.add('lowOpacity'); }, 1000);
    }
    popup.addEventListener('mouseenter', ()=>{ clearTimeout(fadeTO); popup.classList.remove('lowOpacity'); });
    popup.addEventListener('mouseleave', scheduleFade);
    // initial fade unless pinned
    scheduleFade();

    // ensure popup text updates for non-custom nodes if fusion updates
    return popup;
  }

  function removePopup(nodeId){
    const idx = openPopups.findIndex(p => parseInt(p.dataset.nodeId) === nodeId);
    if(idx>=0){
      const el = openPopups[idx];
      // If popup is being dragged, cleanup drag listeners and state
      if (el._dragCleanup) {
        el._dragCleanup();
      }
      el.remove();
      openPopups.splice(idx,1);
    }
  }

  function closeAllPopupsSlow(){
    openPopups.forEach(p=>{
      p.classList.add('fading');
      setTimeout(()=>{ if(p.parentElement) p.parentElement.removeChild(p); }, 5000);
    });
    openPopups = [];
  }

  /* ---- Fusion idea generation & update logic ---- */
  function generateFusion(IDs){
    const texts = IDs.map(id => {
      const n = ideaNodes.find(x => x.id === id);
      return n ? n.ideaText : '';
    }).filter(Boolean);
    if(texts.length === 0) return '';
    const combined = texts.join(' • ');
    const twists = [
      'Together they spark a new perspective.',
      'This fusion uncovers hidden pathways of thought.',
      'Emerging synergy reveals a novel possibility.',
      'A higher-order idea blooms from the overlap.'
    ];
    return combined + ' — ' + choose(twists);
  }

  // When chain changes, update the last popup to show fusion idea
  function updateFusionForChain(){
    if(currentChainIds.length === 0) return;
    const fusion = generateFusion(currentChainIds);
    // update or create popup for last node in chain
    const lastId = currentChainIds[currentChainIds.length-1];
    const node = ideaNodes.find(n=>n.id===lastId);
    if(!node) return;
    // ensure popup exists
    let popup = openPopups.find(p => parseInt(p.dataset.nodeId) === lastId);
    if(!popup){
      popup = createPopupForNode(node);
    }
    // if last node has textarea (custom), don't replace it's textarea; instead show fusion in a linked area
    const textArea = popup.querySelector('textarea');
    if(textArea){
      // create/update a small fusion div below
      let fusionDiv = popup.querySelector('.fusionArea');
      if(!fusionDiv){
        fusionDiv = document.createElement('div');
        fusionDiv.className = 'fusionArea';
        fusionDiv.style.marginTop = '8px';
        fusionDiv.style.padding = '8px';
        fusionDiv.style.borderRadius = '6px';
        fusionDiv.style.background = 'rgba(255,255,255,0.03)';
        fusionDiv.style.fontSize = '0.95rem';
        popup.appendChild(fusionDiv);
      }
      fusionDiv.textContent = fusion;
    } else {
      // replace main text node content for last popup
      let textNode = popup.querySelector('.ideaText');
      if(textNode) textNode.textContent = fusion;
    }
  }

  /* ---- Chain handling (select nodes in sequence) ---- */
  function areDirectlyConnected(a,b){
    return a.connections.has(b.id) && b.connections.has(a.id);
  }

  function selectNode(node){
    if(currentChainIds.length === 0){
      currentChainIds = [node.id];
      highlightedPath = new Set(currentChainIds);
      // create popup for this node
      createPopupForNode(node);
      updateFusionForChain();
      return;
    }
    // check if new selection connects to last chain item
    const lastId = currentChainIds[currentChainIds.length-1];
    const lastNode = ideaNodes.find(n=>n.id===lastId);
    if(lastNode && lastNode.connections.has(node.id)){
      currentChainIds.push(node.id);
      highlightedPath.add(node.id);
      // create popup and update fusion
      createPopupForNode(node);
      updateFusionForChain();
    } else {
      // chain broken - fade old popups and restart
      closeAllPopupsSlow();
      currentChainIds = [node.id];
      highlightedPath = new Set(currentChainIds);
      createPopupForNode(node);
      updateFusionForChain();
    }
  }

  /* ---- Drawing entangled, neuron-like lines ---- */
  function drawEntangledLines(now){
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ideaNodes.forEach(node => {
      node.connections.forEach(connId => {
        // draw each edge once
        if(connId <= node.id) return;
        const other = ideaNodes.find(n=>n.id===connId);
        if(!other) return;

        // compute mid and swirl
        const midX = (node.x + other.x)/2;
        const midY = (node.y + other.y)/2;
        const t = now * 0.003;
        // multi-frequency wiggle -> entanglement-like
        const swirl = Math.sin(t*4 + (node.id+other.id)) * 8 + Math.cos(t*2 + node.id*0.7)*4;

        // choose base hue based on positions/time
        const hue = ( ( (midX+midY)/10 ) + t*60 ) % 360;

        // subtle faint base connection
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255,255,255,0.04)`;
        ctx.lineWidth = 1;
        ctx.moveTo(node.x, node.y);
        ctx.quadraticCurveTo(midX + Math.cos(t + node.id)*swirl, midY + Math.sin(t + other.id)*swirl, other.x, other.y);
        ctx.stroke();

        // if both in highlightedPath, draw more vivid entangled curves + traveling points
        if(highlightedPath.has(node.id) && highlightedPath.has(other.id) &&
           currentChainIds.includes(node.id) && currentChainIds.includes(other.id)){
          // multiple layered curves, slightly offset
          for(let i=0;i<3;i++){
            const offset = (i-1)*6;
            ctx.beginPath();
            const a = node.x + Math.cos(t*1.2 + i + node.id)*offset;
            const b = node.y + Math.sin(t*1.1 + i + node.id)*offset;
            const c = other.x + Math.cos(t*1.3 + i + other.id)*offset;
            const d = other.y + Math.sin(t*1.25 + i + other.id)*offset;
            const ctrlX = midX + Math.cos(t*1.7 + i)* (swirl + offset*0.6);
            const ctrlY = midY + Math.sin(t*1.6 + i)* (swirl + offset*0.6);
            ctx.moveTo(a,b);
            ctx.quadraticCurveTo(ctrlX, ctrlY, c, d);
            ctx.strokeStyle = `hsla(${(hue + i*20)%360}, 85%, ${55 - i*6}%, ${0.28 + i*0.12})`;
            ctx.lineWidth = 1.8 - i*0.3;
            ctx.shadowColor = ctx.strokeStyle;
            ctx.shadowBlur = 6;
            ctx.stroke();
            ctx.shadowBlur = 0;
          }

          // draw traveling particles along the connection to suggest entanglement flow
          const particleCount = 1 + Math.floor(Math.abs(Math.sin(t*2 + node.id))*2);
          for(let p=0;p<particleCount;p++){
            const progress = ( (now*0.002) + p*0.33 + (node.id*0.07) ) % 1;
            // quadratic curve param to position -> simple lerp on curve used
            // approximate point on quadratic curve using de Casteljau for t=progress
            const x0 = node.x, y0 = node.y;
            const x1 = midX + Math.cos(t + node.id)*swirl, y1 = midY + Math.sin(t + other.id)*swirl;
            const x2 = other.x, y2 = other.y;
            // linear mixes
            const xa = x0 + (x1 - x0)*progress;
            const ya = y0 + (y1 - y0)*progress;
            const xb = x1 + (x2 - x1)*progress;
            const yb = y1 + (y2 - y1)*progress;
            const px = xa + (xb - xa)*progress;
            const py = ya + (yb - ya)*progress;
            ctx.beginPath();
            ctx.fillStyle = `hsla(${(hue+progress*60)%360}, 90%, 66%, ${0.95 - progress*0.6})`;
            ctx.arc(px, py, 2.2, 0, Math.PI*2);
            ctx.fill();
          }
        }
      });
    });
  }

  /* ---- Canvas animation ---- */
  let lastTS = performance.now();
  function loop(ts){
    const now = ts || performance.now();
    const delta = Math.max(1, now - lastTS);
    lastTS = now;

    ctx.clearRect(0,0,width,height);

    // Background stylized neurons: layered faint radial blobs + drifting micro-particles
    // subtle moving luminous blobs (parallax)
    drawNeuronBackground(now);

    // update nodes
    ideaNodes.forEach(n => n.update());

    // draw entangled connection lines
    drawEntangledLines(now);

    // draw nodes on top
    ideaNodes.forEach(n => {
      const highlighted = highlightedPath.has(n.id);
      n.draw(ctx, highlighted);
    });

    requestAnimationFrame(loop);
  }

  /* ---- Background neuron stylized effect ---- */
  // small floating glows (not many for perf)
  const blobs = [];
  function initBlobs(){
    blobs.length = 0;
    const bcount = Math.max(6, Math.round((width+height)/800));
    for(let i=0;i<bcount;i++){
      blobs.push({
        x: Math.random()*width,
        y: Math.random()*height,
        r: 120 + Math.random()*160,
        hue: 200 + Math.random()*80,
        offx: Math.random()*2000,
        offy: Math.random()*2000,
      });
    }
  }
  function drawNeuronBackground(now){
    // layered soft blobs
    blobs.forEach((b, idx)=>{
      const t = now*0.00012 + idx;
      const x = b.x + Math.cos(t + b.offx)*18;
      const y = b.y + Math.sin(t + b.offy)*12;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, b.r);
      const hue = b.hue;
      grd.addColorStop(0, `hsla(${hue}, 85%, 62%, ${0.055})`);
      grd.addColorStop(0.35, `hsla(${hue}, 85%, 55%, ${0.025})`);
      grd.addColorStop(1, `rgba(0,0,0,0)`);
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.fillRect(x-b.r, y-b.r, b.r*2, b.r*2);
      ctx.fill();
    });

    // floating micro particles (like synapse dust) — very subtle
    const microCount = Math.min(24, Math.round((width*height)/90000));
    for(let i=0;i<microCount;i++){
      const x = ( (Math.sin((now*0.0002 + i)*1.7) + 1) / 2 ) * width;
      const y = ( (Math.cos((now*0.00015 + i)*1.3) + 1) / 2 ) * height;
      ctx.beginPath();
      ctx.fillStyle = `rgba(200,220,255,${0.02 + (i%3)*0.01})`;
      ctx.arc(x, y, 1.0 + (i%2)*0.6, 0, Math.PI*2);
      ctx.fill();
    }
  }

  /* ---- Interaction: pointer/touch selection to build chains ---- */
  function pointerToCanvasPos(e){
    const rect = canvas.getBoundingClientRect();
    const cx = (e.clientX ?? e.touches?.[0]?.clientX ?? 0) - rect.left;
    const cy = (e.clientY ?? e.touches?.[0]?.clientY ?? 0) - rect.top;
    return {x:cx, y:cy};
  }

  function findNodeAt(x,y){
    // iterate reverse so visually top nodes get detected first
    for(let i=ideaNodes.length-1;i>=0;i--){
      const n = ideaNodes[i];
      const dx = n.x - x, dy = n.y - y;
      if(Math.sqrt(dx*dx + dy*dy) < (n.size + 10)) return n;
    }
    return null;
  }

  canvas.addEventListener('mousedown', (ev)=>{
    const pos = pointerToCanvasPos(ev);
    const node = findNodeAt(pos.x, pos.y);
    if(node) selectNode(node);
  });
  canvas.addEventListener('touchstart', (ev)=>{
    const pos = pointerToCanvasPos(ev);
    const node = findNodeAt(pos.x, pos.y);
    if(node){ selectNode(node); ev.preventDefault(); }
  }, {passive:false});

  /* ---- selectNode wrapper that also opens popups and handles custom node logic ---- */
  function createPopupForNodeIfNeeded(node){
    // ensure popup exists
    let p = openPopups.find(el=>parseInt(el.dataset.nodeId)===node.id);
    if(!p){
      p = createPopupForNode(node);
    }
    // if custom node, focus textarea
    if(node.isCustom){
      const ta = p.querySelector('textarea');
      if(ta) ta.focus();
    }
  }

  function selectNode(node){
    // open popup first (so users see what's selected)
    createPopupForNodeIfNeeded(node);

    // chain logic (only allow extending from last)
    if(currentChainIds.length === 0){
      currentChainIds = [node.id];
      highlightedPath = new Set(currentChainIds);
      updateFusionForChain();
      return;
    }
    const lastId = currentChainIds[currentChainIds.length-1];
    const lastNode = ideaNodes.find(n=>n.id===lastId);
    if(lastNode && lastNode.connections.has(node.id)){
      // extend
      currentChainIds.push(node.id);
      highlightedPath.add(node.id);
      updateFusionForChain();
    } else {
      // break -> fade previous and restart
      closeAllPopupsSlow();
      currentChainIds = [node.id];
      highlightedPath = new Set(currentChainIds);
      updateFusionForChain();
    }
  }

  /* ---- Update fusion text area for chain (applies to visible popups) ---- */
  function updateFusionForChain(){
    // compute fusion text
    const fusion = generateFusion(currentChainIds);
    // show it on the last popup, or create popup
    if(currentChainIds.length===0) return;
    const lastId = currentChainIds[currentChainIds.length-1];
    let popup = openPopups.find(p=>parseInt(p.dataset.nodeId)===lastId);
    if(!popup){
      const node = ideaNodes.find(n=>n.id===lastId);
      popup = createPopupForNode(node);
    }
    // if custom node popup has textarea, show fusion in fusionArea else replace idea text content
    let node = ideaNodes.find(n=>n.id===lastId);
    if(!node) return;
    const ta = popup.querySelector('textarea');
    if(ta){
      let fdiv = popup.querySelector('.fusionArea');
      if(!fdiv){
        fdiv = document.createElement('div');
        fdiv.className = 'fusionArea';
        fdiv.style.marginTop = '8px';
        fdiv.style.padding = '8px';
        fdiv.style.borderRadius = '6px';
        fdiv.style.background = 'rgba(255,255,255,0.03)';
        fdiv.style.fontSize = '0.95rem';
        fdiv.style.color = '#e9f3ff';
        popup.appendChild(fdiv);
      }
      fdiv.textContent = fusion;
    } else {
      const textNode = popup.querySelector('.ideaText');
      if(textNode) textNode.textContent = fusion;
    }
  }

  /* ---- UI controls behavior ---- */
  dashboardToggle.addEventListener('click', ()=>{
    const visible = controlsPanel.classList.toggle('visible');
    dashboardToggle.setAttribute('aria-pressed', visible ? 'true' : 'false');
    controlsPanel.setAttribute('aria-hidden', visible ? 'false' : 'true');
    // when dashboard is visible, ensure it sits above popups (z-index already set high)
  });

  ideaCountSlider.addEventListener('input', (e)=>{
    const val = parseInt(e.target.value,10);
    ideaCountLabel.textContent = val;
  });

  // change handlers that re-create ecosystem on release
  ideaCountSlider.addEventListener('change', ()=>{
    initEnvironment();
  });

  growthRateSlider.addEventListener('input', (e)=>{ growthRateLabel.textContent = e.target.value; });
  challengeSlider.addEventListener('input', (e)=>{ challengeStrengthLabel.textContent = e.target.value; });
  stabilitySlider.addEventListener('input', (e)=>{ stabilityThresholdLabel.textContent = e.target.value; });

  resetBtn.addEventListener('click', ()=>{ initEnvironment(); });

  /* ---- Initialize environment ---- */
  function initEnvironment(){
    resizeCanvas();
    // create nodes based on slider count
    const count = Math.max(3, parseInt(ideaCountSlider.value,10) || INITIAL_COUNT);
    makeNodes(count);
    // init blobs for background
    initBlobs();
    // clear popups and chain
    closeAllPopupsSlow();
    currentChainIds = [];
    highlightedPath = new Set();
  }

  /* ---- Start -----------------------------------------------------------------*/
  initEnvironment();
  requestAnimationFrame(loop);

  // ensure we re-init blobs when resizing
  window.addEventListener('resize', ()=>{ initBlobs(); });

  // small helper to re-evaluate fusion when any node text changed (e.g., custom saved)
  // Observe DOM for textarea changes (if created) to update fusion live
  document.addEventListener('input', e=>{
    if(e.target && e.target.tagName === 'TEXTAREA'){
      const popup = e.target.closest('.popup');
      if(!popup) return;
      const id = parseInt(popup.dataset.nodeId);
      const node = ideaNodes.find(n=>n.id===id);
      if(node){
        node.ideaText = e.target.value;
        updateFusionForChain();
      }
    }
  });

  // expose some functions for debugging
  window._ideaNodes = ideaNodes;
  window._openPopups = openPopups;

})();
</script>
</body>
</html>