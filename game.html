<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Idea Ecosystem</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=SF+Pro+Text&display=swap');

  body, html {
    margin: 0;
    padding: 0;
    overflow: hidden;
    height: 100%;
    background: radial-gradient(circle at center, #0b0c10 0%, #050607 100%);
    font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
      Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    color: white;
    user-select: none;
    font-size: 110%;
  }

  #ecosystem {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background: radial-gradient(circle at center, #0b0c10 0%, #050607 100%);
  }

  canvas {
    display: block;
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 0;
    cursor: pointer;
  }

  /* Dashboard panel moved to left */
  #controlsPanel {
    position: fixed;
    top: 60px;
    left: 0;
    width: 320px;
    max-width: 90vw;
    height: calc(100% - 60px);
    background: rgba(30 30 30 / 0.7);
    backdrop-filter: saturate(180%) blur(25px);
    box-shadow: 2px 0 12px rgba(0,0,0,0.8);
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 20px;
    border-radius: 0 8px 8px 0;
    z-index: 9999; /* Always above all */
    transition: transform 0.3s ease;
    transform: translateX(-100%);
  }

  #controlsPanel.visible {
    transform: translateX(0);
  }

  /* Dashboard toggle button on left */
  #dashboardToggle {
    position: fixed;
    top: 60px;
    left: 0;
    width: 36px;
    height: 36px;
    background: rgba(30 30 30 / 0.7);
    color: white;
    font-size: 28px;
    line-height: 36px;
    text-align: center;
    border-radius: 0 8px 8px 0;
    cursor: pointer;
    z-index: 10000; /* always above controlsPanel */
    user-select: none;
    transition: left 0.3s ease;
    user-select:none;
  }

  /* Shift toggle button when panel visible */
  #controlsPanel.visible + #dashboardToggle {
    left: 320px;
  }

  label {
    display: block;
    font-size: 1rem;
    margin-bottom: 4px;
  }

  input[type=range] {
    width: 100%;
  }

  .metrics {
    font-size: 1rem;
    display: flex;
    justify-content: space-between;
    gap: 8px;
  }

  /* Idea popup styling */
  .ideaPopup {
    position: fixed;
    max-width: 280px;
    padding: 12px 16px 16px 16px;
    background: rgba(30 30 30 / 0.9);
    border-radius: 8px;
    box-shadow:
      0 0 10px 1px rgba(100, 180, 255, 0.25),
      0 0 20px 3px rgba(100, 180, 255, 0.15);
    color: white;
    font-size: 1rem;
    line-height: 1.3;
    user-select: text;
    cursor: default;
    transition: opacity 0.5s ease, filter 0.5s ease;
    z-index: 50; /* below dashboard panel */
    text-shadow:
      0 0 4px rgba(100,180,255,0.6),
      0 0 8px rgba(100,180,255,0.4);
    touch-action: none;
  }

  .ideaPopup.lowOpacity {
    opacity: 0.1 !important;
  }

  .ideaPopup.fading {
    animation: fadeWobble 5s forwards;
  }

  @keyframes fadeWobble {
    0% {
      opacity: 1;
      filter: none;
      transform: translate(0, 0) rotate(0deg);
    }
    50% {
      opacity: 0.5;
      filter: blur(1px);
      transform: translate(3px, -3px) rotate(1deg);
    }
    100% {
      opacity: 0;
      filter: blur(3px);
      transform: translate(0, 0) rotate(-1deg);
    }
  }

  .closeBtn {
    position: absolute;
    top: 6px;
    right: 8px;
    font-weight: 700;
    font-size: 1.3rem;
    color: white;
    cursor: pointer;
    user-select: none;
  }

  .pinBtn {
    position: absolute;
    top: 6px;
    left: 8px;
    width: 20px;
    height: 20px;
    cursor: pointer;
    opacity: 0.7;
    user-select: none;
    fill: white;
    transition: opacity 0.3s ease;
  }
  .pinBtn:hover {
    opacity: 1;
  }
  .pinBtn.pinned {
    opacity: 1;
    filter: drop-shadow(0 0 3px #64b4ff);
  }

  .linkedIdeas {
    margin-top: 10px;
    font-size: 0.95rem;
    color: #aaccee;
  }

  .linkedIdeas span {
    cursor: pointer;
    text-decoration: underline;
    margin-right: 6px;
  }

  .linkedIdeas span:hover {
    color: #77aaff;
  }

</style>
</head>
<body>

<div id="ecosystem">
  <canvas id="ecosystemCanvas"></canvas>

  <div id="controlsPanel">
    <label>Idea Count: <span id="ideaCountLabel">5</span></label>
    <input id="ideaCountSlider" type="range" min="5" max="50" step="1" value="5" />
    <label>Growth Rate: <span id="growthRateLabel">0.2</span></label>
    <input id="growthRateSlider" type="range" min="0.05" max="0.5" step="0.01" value="0.2" />
    <label>Challenge Strength: <span id="challengeStrengthLabel">0.3</span></label>
    <input id="challengeStrengthSlider" type="range" min="0.1" max="0.6" step="0.01" value="0.3" />
    <label>Stability Threshold: <span id="stabilityThresholdLabel">0.7</span></label>
    <input id="stabilityThresholdSlider" type="range" min="0.5" max="0.95" step="0.01" value="0.7" />
    <button id="resetBtn" style="margin-top:20px; padding:8px; border:none; border-radius:8px; background:#4A90E2; color:white; font-weight:bold; cursor:pointer;">
      Reset Ecosystem
    </button>
    <div class="metrics" style="margin-top: 20px;">
      <div>Diversity: <span id="diversityIndexSpan">0</span></div>
      <div>Resilience: <span id="resilienceQuotientSpan">0%</span></div>
      <div>Cognitive Load: <span id="cognitiveLoadSpan">0</span></div>
    </div>
  </div>

  <div id="dashboardToggle" title="Toggle Dashboard">â˜°</div>
</div>

<script>
(() => {
  const ecosystemDiv = document.getElementById('ecosystem');
  const canvas = document.getElementById('ecosystemCanvas');
  const ctx = canvas.getContext('2d');

  const ideaCountSlider = document.getElementById('ideaCountSlider');
  const growthRateSlider = document.getElementById('growthRateSlider');
  const challengeStrengthSlider = document.getElementById('challengeStrengthSlider');
  const stabilityThresholdSlider = document.getElementById('stabilityThresholdSlider');

  const ideaCountLabel = document.getElementById('ideaCountLabel');
  const growthRateLabel = document.getElementById('growthRateLabel');
  const challengeStrengthLabel = document.getElementById('challengeStrengthLabel');
  const stabilityThresholdLabel = document.getElementById('stabilityThresholdLabel');

  const resetBtn = document.getElementById('resetBtn');
  const controlsPanel = document.getElementById('controlsPanel');
  const dashboardToggle = document.getElementById('dashboardToggle');

  let width = ecosystemDiv.clientWidth;
  let height = ecosystemDiv.clientHeight;

  const edgeMargin = 30;

  const gammaWeirdIdeas = [
    "What if you could see invisible radio waves?",
    "What if you could pause time?",
    "What if colors had sounds?",
    "What if trees whispered secrets?",
    "What if you could taste shapes?",
    "What if gravity worked sideways?",
    "What if shadows could dance?",
    "What if memories were physical objects?",
    "What if dreams were parallel lives?",
    "What if you could talk to your past self?"
  ];

  const baseIdeaSnippets = [
    "Creativity sparks connection.",
    "Ideas grow like neurons firing.",
    "Explore the edges of thought.",
    "Unlock potential through curiosity.",
    "Innovation is built on chaos."
  ];

  const gammaStarterIdeas = [
    "Amp up your creativity with wild thoughts.",
    "Let your mind wander freely and connect dots.",
    "Break assumptions and build new paths.",
    "Feed your ideas with playful energy.",
    "Embrace unexpected leaps in thinking."
  ];

  class IdeaNode {
    constructor(id, parentText = null, level = 0, x = null, y = null, ideaText = '', energyBoost = 0, isGammaWeird = false) {
      this.id = id;
      this.level = level;
      this.connections = new Set();
      this.baseSize = 12;
      this.jiggleAmplitude = 0;
      this.jigglePhase = Math.random() * Math.PI * 2;
      this.energyBoost = energyBoost;
      this.isGammaWeird = isGammaWeird;
      this.isGammaStarter = false;
      this.age = 0;
      this.colorHue = Math.floor(200 + (id * 35)) % 360;

      if (x === null || y === null) {
        this.baseX = edgeMargin + Math.random() * (width - edgeMargin * 2);
        this.baseY = edgeMargin + Math.random() * (height - edgeMargin * 2);
      } else {
        this.baseX = Math.min(Math.max(x, edgeMargin), width - edgeMargin);
        this.baseY = Math.min(Math.max(y, edgeMargin), height - edgeMargin);
      }

      this.x = this.baseX;
      this.y = this.baseY;

      this.ideaText = ideaText || this.generateIdeaText(parentText);
    }

    generateIdeaText(parentText) {
      if(this.isGammaWeird) {
        return gammaWeirdIdeas[this.id % gammaWeirdIdeas.length];
      }
      if (this.level === 0) {
        if(Math.random() < 0.25) {
          this.isGammaStarter = true;
          return gammaStarterIdeas[this.id % gammaStarterIdeas.length];
        }
        return baseIdeaSnippets[this.id % baseIdeaSnippets.length];
      }
      let base = parentText || baseIdeaSnippets[this.id % baseIdeaSnippets.length];
      if(this.energyBoost > 0) {
        base += ' + fueled by creative energy!';
      }
      const twistOptions = [
        'Explore new angles.',
        'Shift your perspective.',
        'Embrace the unexpected.',
        'Dive deeper into meaning.',
        'Question all assumptions.',
        'Build upon the unknown.',
        'Connect seemingly unrelated dots.',
        'Let your mind wander.',
        'Transform ideas boldly.',
        'See beyond the obvious.'
      ];
      let twist = twistOptions[Math.floor(Math.random() * twistOptions.length)];
      return base + ' ' + twist;
    }

    update(nodes, growthRate, challengeStrength, isConnected) {
      this.age += 1;
      this.jigglePhase += 0.025;

      const slowFloatSpeed = 0.00015;
      this.baseX += Math.sin(this.age * slowFloatSpeed + this.id) * 0.03;
      this.baseY += Math.cos(this.age * slowFloatSpeed + this.id) * 0.025;

      this.baseX = Math.min(Math.max(this.baseX, edgeMargin), width - edgeMargin);
      this.baseY = Math.min(Math.max(this.baseY, edgeMargin), height - edgeMargin);

      this.jiggleAmplitude = this.connections.size > 0 ? 0.8 : 0;

      this.x = this.baseX + Math.sin(this.jigglePhase) * this.jiggleAmplitude;
      this.y = this.baseY + Math.cos(this.jigglePhase) * this.jiggleAmplitude;

      // Pulsate size slightly
      this.currentSize = this.baseSize + Math.sin(this.age * 0.15 + this.id) * 1.8;
    }

    draw(ctx, highlight) {
      const glowAlpha = highlight ? 0.5 : 0.1;
      const baseColor = `hsl(${this.colorHue}, 70%, ${highlight ? 65 : 50}%)`;

      ctx.shadowColor = `hsla(${this.colorHue}, 80%, 70%, ${glowAlpha})`;
      ctx.shadowBlur = highlight ? 8 : 2;

      ctx.beginPath();
      ctx.fillStyle = baseColor;
      ctx.strokeStyle = `hsla(0, 0%, 100%, ${highlight ? 0.7 : 0.15})`;
      ctx.lineWidth = highlight ? 2 : 1;
      ctx.arc(this.x, this.y, this.currentSize || this.baseSize, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      ctx.shadowBlur = 0;
    }
  }

  let ideaNodes = [];
  let nextId = 0;

  function buildConnections(nodes) {
    for(let node of nodes) {
      node.connections.clear();
    }
    for(let i=0; i<nodes.length; i++) {
      const node = nodes[i];
      if(i+1 < nodes.length) {
        node.connections.add(nodes[i+1].id);
        nodes[i+1].connections.add(node.id);
      }
      if(i+2 < nodes.length && Math.random() > 0.6) {
        node.connections.add(nodes[i+2].id);
        nodes[i+2].connections.add(node.id);
      }
    }
  }

  let openPopups = [];
  let highlightedPath = new Set();
  let currentChainIds = [];
  let fadingTimeout = null;

  function resetEcosystem() {
    ideaNodes = [];
    nextId = 0;
    const count = parseInt(ideaCountSlider.value);

    for(let i=0; i<count; i++) {
      let isGammaWeird = false;
      if(count > 3 && Math.random() < 0.2 && i < gammaWeirdIdeas.length) {
        isGammaWeird = true;
      }
      ideaNodes.push(new IdeaNode(nextId++, null, 0, null, null, '', 0, isGammaWeird));
    }

    buildConnections(ideaNodes);

    currentChainIds = [];
    highlightedPath.clear();
    openPopups.forEach(popup => popup.remove());
    openPopups = [];
  }

  function findNodeAtPos(x, y) {
    for (let node of ideaNodes) {
      const dx = x - node.x;
      const dy = y - node.y;
      if (Math.sqrt(dx*dx + dy*dy) < (node.currentSize || node.baseSize) + 6) return node;
    }
    return null;
  }

  function lightenHsl(h, s=70, l=30, a=0.85) {
    return `hsla(${h}, ${s}%, ${l}%, ${a})`;
  }

  // Create draggable idea popup with pin
  function createPopup(node) {
    for(let popup of openPopups) {
      if(popup.dataset.nodeId == node.id) return popup;
    }

    const ecosystemRect = ecosystemDiv.getBoundingClientRect();
    let left = node.x + ecosystemRect.left - 140;
    let top = node.y + ecosystemRect.top - 110;

    const popup = document.createElement('div');
    popup.className = 'ideaPopup';
    popup.dataset.nodeId = node.id;
    popup.style.background = lightenHsl(node.colorHue, 60, 25, 0.9);
    popup.style.left = `${left}px`;
    popup.style.top = `${top}px`;
    popup.style.borderRadius = '8px';
    popup.style.opacity = '1';
    popup.style.zIndex = 49;

    // Pin state
    let pinned = false;

    // Pin button (SVG)
    const pinBtn = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    pinBtn.setAttribute("viewBox", "0 0 24 24");
    pinBtn.setAttribute("class", "pinBtn");
    pinBtn.innerHTML = `<path fill="white" d="M12 2C10.89 2 10 2.89 10 4v6H4v4h6v6c0 1.11.89 2 2 2s2-.89 2-2v-6h6v-4h-6V4c0-1.11-.89-2-2-2z"/>`;
    popup.appendChild(pinBtn);

    pinBtn.addEventListener('click', e => {
      e.stopPropagation();
      pinned = !pinned;
      if(pinned) {
        pinBtn.classList.add('pinned');
        popup.classList.remove('lowOpacity');
      } else {
        pinBtn.classList.remove('pinned');
      }
    });

    // Drag logic (supports mouse + touch)
    let dragOffsetX = 0, dragOffsetY = 0;
    let isDragging = false;

    function startDrag(e) {
      e.preventDefault();
      isDragging = true;
      pinned = true;
      pinBtn.classList.add('pinned');
      popup.classList.remove('lowOpacity');

      const evt = e.type.startsWith('touch') ? e.touches[0] : e;
      dragOffsetX = evt.clientX - popup.getBoundingClientRect().left;
      dragOffsetY = evt.clientY - popup.getBoundingClientRect().top;
      popup.style.transition = 'none';
    }
    function doDrag(e) {
      if (!isDragging) return;
      const evt = e.type.startsWith('touch') ? (e.touches[0] || e.changedTouches[0]) : e;
      let newX = evt.clientX - dragOffsetX;
      let newY = evt.clientY - dragOffsetY;

      newX = Math.min(window.innerWidth - popup.offsetWidth - 10, Math.max(10, newX));
      newY = Math.min(window.innerHeight - popup.offsetHeight - 10, Math.max(10, newY));

      popup.style.left = newX + 'px';
      popup.style.top = newY + 'px';
    }
    function stopDrag(e) {
      if (!isDragging) return;
      isDragging = false;
      popup.style.transition = 'opacity 0.5s ease';
    }

    popup.addEventListener('mousedown', startDrag);
    popup.addEventListener('touchstart', startDrag, {passive: false});
    window.addEventListener('mousemove', doDrag);
    window.addEventListener('touchmove', doDrag, {passive: false});
    window.addEventListener('mouseup', stopDrag);
    window.addEventListener('touchend', stopDrag);
    window.addEventListener('touchcancel', stopDrag);

    // Close button
    const closeBtn = document.createElement('div');
    closeBtn.className = 'closeBtn';
    closeBtn.textContent = 'Ã—';
    closeBtn.title = 'Close';
    closeBtn.addEventListener('click', e => {
      e.stopPropagation();
      closePopup(node.id);
    });
    popup.appendChild(closeBtn);

    // Idea text content
    const textNode = document.createElement('div');
    textNode.textContent = node.ideaText;
    textNode.style.color = 'white';
    textNode.style.paddingRight = '30px';
    popup.appendChild(textNode);

    // Show connected ideas as clickable links
    if (node.connections.size > 0) {
      const linkedDiv = document.createElement('div');
      linkedDiv.className = 'linkedIdeas';
      linkedDiv.textContent = 'Connected ideas: ';
      node.connections.forEach(connId => {
        const linkSpan = document.createElement('span');
        const connNode = ideaNodes.find(n => n.id === connId);
        if (!connNode) return;
        linkSpan.textContent = (connNode.ideaText.slice(0, 20)) + (connNode.ideaText.length > 20 ? '...' : '');
        linkSpan.title = connNode.ideaText;
        linkSpan.addEventListener('click', e => {
          e.stopPropagation();
          selectNode(connNode);
        });
        linkedDiv.appendChild(linkSpan);
      });
      popup.appendChild(linkedDiv);
    }

    // Opacity control with hover and pin
    let fadeTimeout;
    function scheduleFade() {
      if (pinned || isDragging) return;
      clearTimeout(fadeTimeout);
      fadeTimeout = setTimeout(() => {
        popup.classList.add('lowOpacity');
      }, 1000);
    }
    popup.addEventListener('mouseenter', () => {
      clearTimeout(fadeTimeout);
      popup.classList.remove('lowOpacity');
    });
    popup.addEventListener('mouseleave', () => {
      scheduleFade();
    });
    scheduleFade();

    ecosystemDiv.appendChild(popup);
    openPopups.push(popup);
    return popup;
  }

  function closePopup(nodeId) {
    let index = openPopups.findIndex(p => p.dataset.nodeId == nodeId);
    if (index >= 0) {
      const popup = openPopups[index];
      popup.remove();
      openPopups.splice(index, 1);
    }
  }

  function closeAllPopupsSlow() {
    openPopups.forEach(popup => {
      popup.classList.add('fading');
      setTimeout(() => {
        if (popup.parentElement) popup.parentElement.removeChild(popup);
      }, 5000);
    });
    openPopups = [];
  }

  function highlightPathTo(node) {
    if (currentChainIds.length === 0) {
      currentChainIds = [node.id];
      highlightedPath = new Set([node.id]);
      return;
    }

    let lastNodeId = currentChainIds[currentChainIds.length - 1];
    if (ideaNodes.find(n => n.id === lastNodeId).connections.has(node.id)) {
      currentChainIds.push(node.id);
      highlightedPath.add(node.id);
    } else {
      closeAllPopupsSlow();
      currentChainIds = [node.id];
      highlightedPath = new Set([node.id]);
    }
  }

  function selectNode(node) {
    highlightPathTo(node);
    createPopup(node);
  }

  function draw() {
    ctx.clearRect(0, 0, width, height);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // Draw faint connection lines
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.lineWidth = 1;

    for (let node of ideaNodes) {
      for (let connId of node.connections) {
        if (node.id < connId) {
          const connNode = ideaNodes.find(n => n.id === connId);
          ctx.beginPath();
          ctx.moveTo(node.x, node.y);
          ctx.lineTo(connNode.x, connNode.y);
          ctx.stroke();
        }
      }
    }

    // Draw highlighted path connections with swirling rainbow effect
    const time = performance.now() / 1000;

    for (let i = 1; i < currentChainIds.length; i++) {
      const n1 = ideaNodes.find(n => n.id === currentChainIds[i - 1]);
      const n2 = ideaNodes.find(n => n.id === currentChainIds[i]);
      if (!n1 || !n2) continue;

      const swirlAmplitude = 7;
      const swirlFrequency = 4;
      const swirlOffsetX = Math.sin(time * swirlFrequency + i) * swirlAmplitude;
      const swirlOffsetY = Math.cos(time * swirlFrequency + i) * swirlAmplitude;

      const startX = n1.x + swirlOffsetX;
      const startY = n1.y + swirlOffsetY;
      const endX = n2.x + swirlOffsetX;
      const endY = n2.y + swirlOffsetY;

      const hueShift = (time * 120 + i * 50) % 360;
      ctx.strokeStyle = `hsla(${hueShift}, 85%, 65%, 0.6)`;
      ctx.lineWidth = 3;

      ctx.shadowColor = ctx.strokeStyle;
      ctx.shadowBlur = 12;

      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();

      ctx.shadowBlur = 0;
    }

    // Draw idea nodes with pulsate and jiggle if connected
    for (let node of ideaNodes) {
      const isHighlighted = highlightedPath.has(node.id);

      // Jiggle if connected
      if (node.connections.size > 0) {
        node.jiggleAmplitude = 0.8;
      } else {
        node.jiggleAmplitude = 0;
      }
      node.draw(ctx, isHighlighted);
    }
  }

  function update() {
    for (let node of ideaNodes) {
      node.update(ideaNodes, parseFloat(growthRateSlider.value), parseFloat(challengeStrengthSlider.value));
    }
  }

  function animate() {
    update();
    draw();
    requestAnimationFrame(animate);
  }

  canvas.addEventListener('click', e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const clickedNode = findNodeAtPos(mx, my);
    if (clickedNode) {
      selectNode(clickedNode);
    }
  });

  resetBtn.addEventListener('click', () => {
    resetEcosystem();
  });

  dashboardToggle.addEventListener('click', () => {
    controlsPanel.classList.toggle('visible');
  });

  function resize() {
    width = ecosystemDiv.clientWidth;
    height = ecosystemDiv.clientHeight;
    canvas.width = width * devicePixelRatio;
    canvas.height = height * devicePixelRatio;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(devicePixelRatio, devicePixelRatio);
  }

  ideaCountSlider.addEventListener('input', e => {
    ideaCountLabel.textContent = ideaCountSlider.value;
    resetEcosystem();
  });
  growthRateSlider.addEventListener('input', e => {
    growthRateLabel.textContent = growthRateSlider.value;
  });
  challengeStrengthSlider.addEventListener('input', e => {
    challengeStrengthLabel.textContent = challengeStrengthSlider.value;
  });
  stabilityThresholdSlider.addEventListener('input', e => {
    stabilityThresholdLabel.textContent = stabilityThresholdSlider.value;
  });

  window.addEventListener('resize', resize);

  resize();
  resetEcosystem();
  animate();
})();
</script>
</body>
</html>